<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四渡赤水 - 终极战术指挥系统 (AAA级)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@600&family=Noto+Serif+SC:wght@500;900&family=Share+Tech+Mono&display=swap');

        :root {
            --red-core: #ff0f0f;
            --red-glow: #ff5d5d;
            --blue-core: #00f2ff;
            --bg-color: #030303;
            --glass: rgba(8, 8, 10, 0.88);
            --border: 1px solid rgba(255, 50, 50, 0.3);
            --grid-lines: rgba(255, 255, 255, 0.02);
            --hud-outline: rgba(255, 255, 255, 0.08);
            --scanline: rgba(255, 255, 255, 0.04);
        }

        body, html {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at 20% 20%, rgba(255, 20, 20, 0.08), transparent 55%),
                        radial-gradient(circle at 80% 0%, rgba(0, 200, 255, 0.08), transparent 45%),
                        var(--bg-color);
            font-family: 'Share Tech Mono', monospace;
            color: #fff;
            user-select: none;
            height: 100%;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image: linear-gradient(transparent 95%, var(--grid-lines) 95%), linear-gradient(90deg, transparent 95%, var(--grid-lines) 95%);
            background-size: 140px 140px;
            pointer-events: none;
            opacity: 0.4;
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(180deg, transparent 0px, transparent 6px, var(--scanline) 7px);
            mix-blend-mode: screen;
            pointer-events: none;
            opacity: 0.25;
        }

        #canvas-container { position: absolute; inset: 0; }

        #canvas-container::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 80%, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.85));
            pointer-events: none;
        }

        /* === 加载层 === */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s; pointer-events: none;
        }
        .load-ring { width: 60px; height: 60px; border: 2px solid #222; border-top: 2px solid var(--red-core); border-radius: 50%; animation: spin 0.8s infinite linear; margin-bottom: 15px; }
        .load-txt { color: var(--red-core); letter-spacing: 4px; font-size: 12px; animation: blink 1s infinite; }

        /* === 核心 HUD === */
        .hud-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            padding: 30px;
            display: grid;
            grid-template-columns: 380px 1fr 380px;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
        }

        .hud-layer::before {
            content: '';
            position: absolute;
            inset: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            pointer-events: none;
            box-shadow: 0 0 30px rgba(255, 20, 20, 0.1);
        }

        .corner {
            position: absolute;
            width: 70px;
            height: 70px;
            border: 2px solid var(--hud-outline);
            pointer-events: none;
            mix-blend-mode: screen;
            animation: cornerGlow 6s infinite;
        }
        .corner.tl { top: 18px; left: 18px; border-right: none; border-bottom: none; }
        .corner.tr { top: 18px; right: 18px; border-left: none; border-bottom: none; }
        .corner.bl { bottom: 18px; left: 18px; border-right: none; border-top: none; }
        .corner.br { bottom: 18px; right: 18px; border-left: none; border-top: none; }

        /* 顶部：时间核心 */
        .top-bar {
            grid-column: 2;
            grid-row: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
            position: relative;
        }
        .op-badge { 
            border: 1px solid transparent; color: var(--red-core); font-size: 11px; padding: 4px 18px; 
            letter-spacing: 6px; background: linear-gradient(90deg, rgba(255, 20, 20, 0.15), rgba(255, 20, 20, 0)); margin-bottom: 12px; box-shadow: 0 0 18px rgba(255,0,0,0.4);
            text-transform: uppercase; position: relative; overflow: hidden;
        }
        .op-badge::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 50%, rgba(255,80,80,0.6), transparent 70%);
            opacity: 0.2;
        }
        .date-container { position: relative; padding: 5px 40px; }
        .date-container::after {
            content: '';
            position: absolute;
            inset: 0;
            border: 1px solid rgba(255, 60, 60, 0.35);
            filter: blur(3px);
            pointer-events: none;
        }
        .date-display { 
            font-family: 'Rajdhani', sans-serif; font-size: 5.5rem; font-weight: 900; color: rgba(255,255,255,0.45); 
            letter-spacing: 12px; line-height: 1; transition: color 0.2s;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 80px rgba(255, 15, 15, 0.85);
            mix-blend-mode: screen;
        }
        
        /* 左侧：情报面板 */
        .panel-left { 
            grid-column: 1; grid-row: 2; align-self: center;
            background: linear-gradient(90deg, var(--glass) 0%, transparent 100%);
            border-left: 4px solid var(--red-core); padding: 30px;
            transform: translateX(-120%); transition: transform 0.5s cubic-bezier(0.2, 1, 0.3, 1);
            pointer-events: auto; backdrop-filter: blur(10px);
            box-shadow: 20px 0 60px rgba(0,0,0,0.8);
        }
        .panel-left.active { transform: translateX(0); }
        .panel-left.blue { border-left-color: var(--blue-core); }

        .p-header { display: flex; justify-content: space-between; align-items: flex-end; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 15px; }
        .p-title { font-family: 'Noto Serif SC'; font-size: 2.4rem; margin: 0; line-height: 1; text-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .p-type { font-size: 10px; color: #888; letter-spacing: 2px; font-weight: bold; }
        
        .p-text { font-family: 'Noto Serif SC'; font-size: 1rem; line-height: 1.8; color: #ccc; min-height: 120px; text-align: justify; }
        
        .p-stats { margin-top: 20px; display: flex; gap: 20px; }
        .stat-item { display: flex; flex-direction: column; }
        .stat-lbl { font-size: 8px; color: #555; letter-spacing: 1px; margin-bottom: 2px; }
        .stat-val { font-size: 16px; font-weight: bold; color: var(--red-core); text-shadow: 0 0 5px var(--red-core); }

        /* 右侧：雷达 */
        .panel-right { grid-column: 3; grid-row: 2; display: flex; flex-direction: column; align-items: flex-end; pointer-events: none; opacity: 0.8; }
        .radar-ui { width: 150px; height: 150px; border: 2px solid #333; border-radius: 50%; position: relative; overflow: hidden; background: radial-gradient(circle, transparent 30%, rgba(20,0,0,0.4) 100%); margin-bottom: 15px; }
        .radar-sweep { position: absolute; inset: 0; background: conic-gradient(transparent 270deg, var(--red-core)); opacity: 0.3; animation: sweep 2s linear infinite; border-radius: 50%; }
        .info-list { text-align: right; font-size: 12px; color: #777; line-height: 1.6; border-right: 2px solid #333; padding-right: 15px; }
        .hl { color: #fff; font-weight: bold; }

        /* 底部：控制 */
        .controls { grid-column: 2; grid-row: 3; justify-self: center; display: flex; align-items: center; gap: 25px; background: var(--glass); padding: 12px 40px; border-radius: 60px; border: 1px solid #333; pointer-events: auto; }
        .btn { background: none; border: 1px solid var(--red-core); color: var(--red-core); width: 48px; height: 48px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: 0.2s; }
        .btn:hover { background: var(--red-core); color: #000; box-shadow: 0 0 20px var(--red-core); }
        input[type=range] { width: 400px; accent-color: var(--red-core); cursor: pointer; height: 2px; background: #333; }

        /* CSS2D 标签 */
        .label-root { cursor: pointer; pointer-events: auto; transition: 0.2s; display: flex; flex-direction: column; align-items: center; }
        .label-root:hover { transform: scale(1.2); z-index: 100; }
        .l-icon { width: 6px; height: 6px; background: #fff; border-radius: 50%; box-shadow: 0 0 10px #fff; margin-bottom: 5px; position: relative; }
        /* 呼吸光环 */
        .l-icon::before { content:''; position:absolute; inset:-10px; border:1px solid currentColor; border-radius:50%; opacity:0; animation: ripple 2s infinite; }
        .l-txt { 
            font-family: 'Noto Serif SC'; font-weight: 900; font-size: 11px; 
            background: rgba(0,0,0,0.85); padding: 4px 10px; border-radius: 2px; 
            white-space: nowrap; border-left: 2px solid #fff; backdrop-filter: blur(4px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.8);
        }

        /* 颜色变体 */
        .theme-red { color: var(--red-core); }
        .theme-red .l-icon { background: var(--red-core); box-shadow: 0 0 15px var(--red-core); }
        .theme-red .l-txt { border-color: var(--red-core); color: #ffebeb; }

        .theme-blue { color: var(--blue-core); }
        .theme-blue .l-icon { background: var(--blue-core); box-shadow: 0 0 15px var(--blue-core); }
        .theme-blue .l-txt { border-color: var(--blue-core); color: #e0ffff; }

        @keyframes sweep { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes blink { 50% { opacity: 0.5; } }
        @keyframes ripple { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }
        @keyframes cornerGlow {
            0%, 100% { box-shadow: 0 0 8px rgba(255,255,255,0.15); opacity: 0.6; }
            50% { box-shadow: 0 0 16px rgba(255,0,0,0.4); opacity: 1; }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="load-ring"></div>
        <div class="load-txt">TACTICAL SYSTEM INITIALIZING</div>
    </div>

    <div id="canvas-container" style="position: absolute; inset: 0;"></div>

    <div class="hud-layer">
        <div class="corner tl"></div><div class="corner tr"></div><div class="corner bl"></div><div class="corner br"></div>

        <div class="top-bar">
            <div class="op-badge">OPERATION: LONG MARCH</div>
            <div class="date-container">
                <div id="ui-date" class="date-display">1935</div>
            </div>
        </div>

        <div class="panel-left" id="info-panel">
            <div class="p-header">
                <h1 class="p-title" id="ui-title">遵义</h1>
                <span class="p-type" id="ui-type">HQ ESTABLISHED</span>
            </div>
            <div class="p-text" id="ui-desc">
                战术指挥系统已上线。等待指令。
            </div>
            <div class="p-stats">
                <div class="stat-item"><span class="stat-lbl">LOC</span><span class="stat-val" id="ui-loc">ZUNYI</span></div>
                <div class="stat-item"><span class="stat-lbl">THREAT</span><span class="stat-val" id="ui-status">HIGH</span></div>
            </div>
        </div>

        <div class="panel-right">
            <div class="radar-ui"><div class="radar-sweep"></div></div>
            <div class="info-list">
                <div>ELEVATION: <span class="hl" id="ui-ele">--</span></div>
                <div>TERRAIN: <span class="hl">KARST</span></div>
                <div>HOSTILES: <span class="hl" style="color: var(--blue-core)">DETECTED</span></div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="btn-play">▶</button>
            <input type="range" id="timeline" min="0" max="100" value="0" step="0.1">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { createNoise2D } from 'simplex-noise';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // === 配置 ===
        const CONFIG = {
            colors: {
                red: 0xff0f0f,
                blue: 0x00f2ff, // 高亮电光蓝
                bg: 0x000000,
                grid: 0xaa0000 // 深红网格
            },
            terrain: { size: 340, res: 256 }
        };

        // === 1. 场景搭建 ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.bg);
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.003);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 2000);
        camera.position.set(0, 160, 180);

        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 40;
        controls.maxDistance = 400;

        // === 2. 黑曜石地形 + 红色扫描网格 (Shader) ===
        const noise2D = createNoise2D();
        function getHeight(x, z) {
            let y = noise2D(x*0.01, z*0.01) * 26;
            y += noise2D(x*0.03, z*0.03) * 8;
            const river = Math.sin(x*0.025) * 40 + Math.cos(x*0.06) * 12;
            const dist = Math.abs(z - river);
            const valley = THREE.MathUtils.smoothstep(dist, 4, 35);
            return y * valley - (1.0 - valley) * 12;
        }

        const geo = new THREE.PlaneGeometry(CONFIG.terrain.size, CONFIG.terrain.size, CONFIG.terrain.res, CONFIG.terrain.res);
        const pos = geo.attributes.position;
        for(let i=0; i<pos.count; i++) pos.setZ(i, getHeight(pos.getX(i), pos.getY(i)));
        geo.computeVertexNormals();

        const terrainMat = new THREE.ShaderMaterial({
            uniforms: {
                uGrid: { value: new THREE.Color(CONFIG.colors.grid) },
                uBase: { value: new THREE.Color(0x050505) },
                uTime: { value: 0 }
            },
            vertexShader: `
                varying vec3 vPos;
                void main() {
                    vPos = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uGrid;
                uniform vec3 uBase;
                uniform float uTime;
                varying vec3 vPos;
                void main() {
                    vec3 color = uBase;
                    
                    // 战术网格
                    float scale = 8.0;
                    float width = 0.05;
                    vec2 grid = fract(vPos.xy / scale);
                    float line = step(1.0 - width, max(grid.x, grid.y));
                    color += line * uGrid * 0.3;

                    // 扫描光波
                    float scanY = fract(uTime * 0.1) * 400.0 - 200.0;
                    float scanDist = abs(vPos.y - scanY);
                    float beam = smoothstep(20.0, 0.0, scanDist);
                    color += beam * vec3(1.0, 0.1, 0.1) * 0.5; // 红色光束

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        const terrain = new THREE.Mesh(geo, terrainMat);
        terrain.rotation.x = -Math.PI/2;
        scene.add(terrain);

        // 黑色水面
        const water = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.terrain.size, CONFIG.terrain.size), new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.9}));
        water.rotation.x = -Math.PI/2;
        water.position.y = -8;
        scene.add(water);

        // 灯光
        scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        const dl = new THREE.DirectionalLight(0xffffff, 0.8);
        dl.position.set(-50, 100, 50);
        scene.add(dl);


        // === 3. 能量流体路线 (Tube + Flow Shader) ===
        function createEnergyRoute(points, color, isMain) {
            const curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.4);
            
            // 管道几何体
            const tubeGeo = new THREE.TubeGeometry(curve, 400, isMain?0.6:0.4, 6, false);
            
            // 流动材质
            const flowMat = new THREE.ShaderMaterial({
                uniforms: {
                    uColor: { value: new THREE.Color(color) },
                    uTime: { value: 0 },
                    uProgress: { value: 0 } // 控制生长
                },
                transparent: true,
                depthTest: false, // 永远显示（透视）
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    uniform float uTime;
                    uniform float uProgress;
                    varying vec2 vUv;
                    void main() {
                        // 生长控制
                        if (vUv.x > uProgress) discard;

                        // 能量脉冲纹理
                        float flow = fract(vUv.x * 10.0 - uTime * 2.0);
                        float beam = smoothstep(0.4, 0.6, flow) - smoothstep(0.6, 0.8, flow);
                        
                        // 边缘发光
                        float alpha = 0.4 + beam * 0.6; 
                        
                        // 头部高亮
                        float head = smoothstep(uProgress - 0.05, uProgress, vUv.x);
                        vec3 finalColor = mix(uColor, vec3(1.0), head);

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `
            });

            const mesh = new THREE.Mesh(tubeGeo, flowMat);
            // 提升高度贴合地形
            // 这里为了简化计算，假设Tube在空中，我们在render时更新位置不太现实
            // 所以我们重新计算curve点的高度
            const count = tubeGeo.attributes.position.count;
            const posArr = tubeGeo.attributes.position.array;
            for(let i=0; i<count; i++) {
                // TubeGeometry 顶点是围绕中心线的，这里简化处理，整体抬高
                // 更好的方式是重写TubeGeometry的生成逻辑，但这里我们简单抬高Mesh即可
                // 实际上 Tube 生成后是静态的。为了贴地，我们需要生成时就贴地。
                // 重新生成贴地 Curve
            }
            // 简单方案：把Mesh设在y=0，生成Curve时带高度
            return { mesh, mat: flowMat, curve };
        }

        // 重新生成带高度的路径点
        function makeGroundPoints(pts) {
            return pts.map(p => new THREE.Vector3(p.x, getHeight(p.x, p.z) + 2.5, p.z));
        }

        const redPoints = makeGroundPoints([
            new THREE.Vector3(60,0,20), new THREE.Vector3(-40,0,-30), new THREE.Vector3(-90,0,-20),
            new THREE.Vector3(10,0,-10), new THREE.Vector3(20,0,50), new THREE.Vector3(-20,0,-40), new THREE.Vector3(80,0,100)
        ]);
        const redRoute = createEnergyRoute(redPoints, CONFIG.colors.red, true);
        scene.add(redRoute.mesh);

        const bluePoints1 = makeGroundPoints([new THREE.Vector3(130,0,20), new THREE.Vector3(80,0,30), new THREE.Vector3(40,0,50), new THREE.Vector3(20,0,90)]);
        const blueRoute1 = createEnergyRoute(bluePoints1, CONFIG.colors.blue, false);
        scene.add(blueRoute1.mesh);
        
        const bluePoints2 = makeGroundPoints([new THREE.Vector3(-70,0,-110), new THREE.Vector3(-60,0,-70), new THREE.Vector3(-30,0,-50)]);
        const blueRoute2 = createEnergyRoute(bluePoints2, CONFIG.colors.blue, false);
        scene.add(blueRoute2.mesh);


        // === 4. 交互节点 (Hitbox + 标签) ===
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const interactables = [];

        function createNode(d) {
            const y = getHeight(d.x, d.z);
            const grp = new THREE.Group();
            grp.position.set(d.x, y, d.z);
            
            // 1. 光柱
            const beam = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 40, 8),
                new THREE.MeshBasicMaterial({color: d.type==='red'?CONFIG.colors.red:CONFIG.colors.blue, transparent:true, opacity:0.3, blending:THREE.AdditiveBlending})
            );
            beam.position.y = 20;
            grp.add(beam);

            // 2. 隐形点击盒
            const hit = new THREE.Mesh(new THREE.BoxGeometry(10,60,10), new THREE.MeshBasicMaterial({visible:false}));
            hit.position.y = 30;
            hit.userData = d;
            grp.add(hit);
            interactables.push(hit);

            // 3. 标签
            const div = document.createElement('div');
            div.className = `label-root theme-${d.type}`;
            div.innerHTML = `<div class="l-icon"></div><div class="l-txt">${d.name}</div>`;
            div.onclick = (e) => { e.stopPropagation(); focusNode(d, grp.position); };
            
            const label = new CSS2DObject(div);
            label.position.set(0, 45, 0);
            grp.add(label);

            scene.add(grp);
            return { beam };
        }

        const nodes = [
            { p:0, x:60, z:20, name:"遵义", type:"red", date:"1935.01.15", s:"HQ", desc:"中共中央政治局扩大会议在此召开。确立了毛泽东在党和红军的领导地位，挽救了党，挽救了红军。"},
            { p:0.18, x:-40, z:-30, name:"土城", type:"red", date:"1935.01.29", s:"BATTLE", desc:"一渡赤水。因情报有误遭遇川军重兵，毛泽东果断决定撤出战斗，西渡赤水河，拉开四渡赤水序幕。"},
            { p:0.35, x:-90, z:-20, name:"扎西", type:"red", date:"1935.02.09", s:"REGROUP", desc:"扎西整编。红军在川滇黔边境集结，缩编师为团，精简行装，利用敌人被引向西侧之机，准备回师东进。"},
            { p:0.5, x:10, z:-10, name:"二郎滩", type:"red", date:"1935.02.18", s:"VICTORY", desc:"二渡赤水。杀个回马枪！红军二渡赤水，奇袭娄山关，二占遵义，取得长征以来最大的一次胜利。"},
            { p:0.7, x:20, z:50, name:"茅台", type:"red", date:"1935.03.16", s:"DECEPTION", desc:"三渡赤水。红军大造声势，再次西进茅台，佯装北渡长江，成功将国民党重兵引向川南古蔺地区。"},
            { p:0.85, x:-20, z:-40, name:"太平渡", type:"red", date:"1935.03.21", s:"BREAKOUT", desc:"四渡赤水。趁敌军中计西调，红军秘密折返，从太平渡、二郎滩四渡赤水，随即南渡乌江，兵临贵阳。"},
            
            { x:-60, z:-80, name:"川军防线", type:"blue", date:"ENEMY", s:"BLOCKADE", desc:"刘湘部精锐，依托长江天险和碉堡防线，企图阻止红军北上入川。"},
            { x:110, z:10, name:"中央军", type:"blue", date:"ENEMY", s:"PURSUIT", desc:"薛岳兵团主力，装备精良，从东面紧追不舍，是红军最危险的对手。"}
        ];
        const nodeRefs = nodes.map(createNode);


        // === 5. 视觉特效 (Bloom) ===
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight), 1.5, 0.4, 0.85);
        bloom.threshold = 0.15; bloom.strength = 1.8; bloom.radius = 0.6;
        composer.addPass(bloom);

        // === 6. 逻辑中心 ===
        let progress = 0, targetProgress = 0, isPlaying = false, activeIdx = -1;
        const ui = {
            date: document.getElementById('ui-date'),
            panel: document.getElementById('info-panel'),
            title: document.getElementById('ui-title'),
            type: document.getElementById('ui-type'),
            desc: document.getElementById('ui-desc'),
            loc: document.getElementById('ui-loc'),
            stat: document.getElementById('ui-status'),
            ele: document.getElementById('ui-ele'),
            btn: document.getElementById('btn-play'),
            bar: document.getElementById('timeline')
        };

        // 打字机
        let typeInt;
        function typeWriter(txt) {
            clearInterval(typeInt); ui.desc.innerText = ""; let i=0;
            typeInt = setInterval(()=>{ ui.desc.innerText+=txt.charAt(i); i++; if(i>=txt.length) clearInterval(typeInt); }, 15);
        }

        // 时间爆炸特效 (GSAP)
        function flashTime(dateText) {
            ui.date.innerText = dateText;
            gsap.killTweensOf(ui.date);
            gsap.timeline()
                .fromTo(ui.date,
                    { scale: 1.3, color: "#fff", textShadow: "0 0 90px rgba(255,255,255,0.9), 0 0 200px rgba(255,0,0,1)" },
                    { duration: 0.35, ease: "power2.out", color: "#fff", textShadow: "0 0 60px rgba(255,255,255,0.9), 0 0 150px rgba(255,0,0,0.9)" }
                )
                .to(ui.date, {
                    duration: 0.7,
                    ease: "power2.out",
                    scale: 1.08,
                    color: "rgba(255,255,255,0.65)",
                    textShadow: "0 0 35px rgba(255,255,255,0.7), 0 0 120px rgba(255,0,0,0.75)"
                })
                .to(ui.date, {
                    duration: 0.6,
                    ease: "power2.inOut",
                    scale: 1.02,
                    color: "rgba(255,255,255,0.45)",
                    textShadow: "0 0 20px rgba(255,255,255,0.6), 0 0 80px rgba(255,15,15,0.6)"
                });
        }

        function focusNode(d, pos) {
            isPlaying = false; ui.btn.innerText = "RESUME";
            
            ui.panel.classList.add('active');
            if(d.type==='blue') ui.panel.classList.add('blue'); else ui.panel.classList.remove('blue');
            
            ui.title.innerText = d.name;
            ui.type.innerText = d.type==='red' ? "RED ARMY EVENT" : "ENEMY INTEL";
            ui.loc.innerText = `${d.x.toFixed(0)}, ${d.z.toFixed(0)}`;
            ui.stat.innerText = d.s;
            ui.stat.style.color = d.type==='red' ? 'var(--red-core)' : 'var(--blue-core)';
            typeWriter(d.desc);

            if(d.date !== 'ENEMY') flashTime(d.date);

            gsap.to(camera.position, {x:pos.x+30, y:pos.y+50, z:pos.z+50, duration:1.5, ease:"power2.inOut"});
            gsap.to(controls.target, {x:pos.x, y:pos.y, z:pos.z, duration:1.5, ease:"power2.inOut"});
        }

        // 交互
        window.onclick = (e) => {
            if(e.target.closest('.hud-layer')) return;
            mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length>0) focusNode(hits[0].object.userData, hits[0].object.parent.position);
        };
        ui.btn.onclick = ()=>{ 
            if(targetProgress>=1) targetProgress=0; 
            isPlaying=!isPlaying; 
            ui.btn.innerText=isPlaying?"PAUSE":"RESUME";
            if(isPlaying) ui.panel.classList.remove('active');
        };
        ui.bar.oninput = ()=>{ isPlaying=false; ui.btn.innerText="RESUME"; };

        // Init
        setTimeout(()=>{
            document.getElementById('loader').style.opacity=0;
            setTimeout(()=>document.getElementById('loader').remove(), 800);
            ui.panel.classList.add('active');
            typeWriter("指挥官，战术终端已就绪。敌军（蓝色光流）正从东、北两面实施包围。点击 [INITIATE] 开始推演。");
        }, 1000);

        // 循环
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update Shader Uniforms
            terrainMat.uniforms.uTime.value = time;
            redRoute.mat.uniforms.uTime.value = time;
            blueRoute1.mat.uniforms.uTime.value = time;
            blueRoute2.mat.uniforms.uTime.value = time;

            if(isPlaying) {
                targetProgress += dt * 0.05;
                if(targetProgress>=1) { targetProgress=1; isPlaying=false; ui.btn.innerText="REPLAY"; }
                ui.bar.value = targetProgress*100;
            } else {
                targetProgress = parseFloat(ui.bar.value)/100;
            }
            progress += (targetProgress - progress) * 0.1;

            // 1. 路线生长 (Shader)
            redRoute.mat.uniforms.uProgress.value = progress;
            
            // 敌军滞后追击
            const blueProg = Math.max(0, progress - 0.15);
            blueRoute1.mat.uniforms.uProgress.value = blueProg;
            blueRoute2.mat.uniforms.uProgress.value = blueProg;

            // 2. 触发逻辑 (时间爆发)
            let hitIdx = -1;
            nodes.forEach((n,i)=>{ if(n.type==='red' && Math.abs(progress - n.p)<0.02) hitIdx=i; });
            
            if(hitIdx !== -1 && hitIdx !== activeIdx && isPlaying) {
                activeIdx = hitIdx;
                const n = nodes[hitIdx];
                
                // 时间爆发！
                flashTime(n.date);
                
                // 光柱闪烁
                const beam = nodeRefs[hitIdx].beam;
                gsap.fromTo(beam.material, {opacity:1}, {opacity:0.3, duration:0.5, repeat:3, yoyo:true});
                
                // 自动弹窗
                ui.panel.classList.add('active'); ui.panel.classList.remove('blue');
                ui.title.innerText = n.name;
                ui.type.innerText = "EVENT TRIGGERED";
                typeWriter(n.desc);
            }

            // 3. 相机跟随
            if(isPlaying) {
                const pt = redRoute.curve.getPointAt(progress);
                const y = getHeight(pt.x, pt.z);
                const camTarget = new THREE.Vector3(pt.x, y+60, pt.z+80);
                camera.position.lerp(camTarget, 0.05);
                controls.target.lerp(new THREE.Vector3(pt.x, y, pt.z), 0.05);
                ui.ele.innerText = Math.floor(y*100+500) + "m";
            }

            controls.update();
            composer.render();
            labelRenderer.render(scene, camera);
        }
        animate();
        window.onresize=()=>{
            camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();
            renderer.setSize(innerWidth,innerHeight);labelRenderer.setSize(innerWidth,innerHeight);
            composer.setSize(innerWidth,innerHeight);
        };
    </script>
</body>
</html>